<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>CHESSâ„¢ BUT ITALIAN BRAINROT EDITION</title>
  <style>
    :root {
      --bg: #0a0a0f;
      --board-light: #f0d9b5;
      --board-dark: #b58863;
      --text: #ff00ff;
      --cyan: #00ffff;
      --red: #ff1744;
      --yellow: #ffeb3b;
      --green: #00ff00;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      font-family: 'Comic Sans MS', 'Impact', sans-serif;
      color: var(--text);
      overflow: hidden;
      position: relative;
    }

    /* GLITCH BACKGROUND */
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background:
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,0,255,.03) 2px, rgba(255,0,255,.03) 4px),
        repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0,255,255,.03) 2px, rgba(0,255,255,.03) 4px),
        radial-gradient(circle at 20% 30%, rgba(255,0,255,.15), transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(0,255,255,.12), transparent 50%);
      pointer-events: none;
      z-index: 0;
      animation: glitch 0.1s infinite;
    }

    @keyframes glitch {
      0%, 100% { transform: translate(0); }
      20% { transform: translate(-2px, 2px); }
      40% { transform: translate(-2px, -2px); }
      60% { transform: translate(2px, 2px); }
      80% { transform: translate(2px, -2px); }
    }

    /* CRT SCANLINES */
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(
        to bottom,
        transparent,
        transparent 2px,
        rgba(0,0,0,.3) 2px,
        rgba(0,0,0,.3) 4px
      );
      pointer-events: none;
      z-index: 1000;
      mix-blend-mode: multiply;
      opacity: 0.4;
    }

    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1;
      padding: 10px;
    }

    /* TITLE BAR */
    .title-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
      background-size: 200% 100%;
      padding: 8px;
      text-align: center;
      font-size: 24px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 4px;
      color: #000;
      text-shadow:
        2px 2px 0 #fff,
        -2px -2px 0 #fff,
        2px -2px 0 #fff,
        -2px 2px 0 #fff;
      animation: titleWave 2s linear infinite;
      z-index: 100;
      border-bottom: 4px solid #000;
      box-shadow: 0 4px 20px rgba(255,0,255,.5);
    }

    @keyframes titleWave {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }

    .game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      margin-top: 60px;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* CHESS BOARD */
    .board-container {
      position: relative;
      background: #222;
      padding: 15px;
      border: 6px solid;
      border-image: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00) 1;
      box-shadow:
        0 0 30px rgba(255,0,255,.6),
        0 0 60px rgba(0,255,255,.4),
        inset 0 0 30px rgba(0,0,0,.5);
      transform: perspective(1000px) rotateX(2deg);
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      width: min(80vmin, 600px);
      height: min(80vmin, 600px);
      gap: 0;
      border: 4px solid #000;
      position: relative;
    }

    .square {
      width: 100%;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    .square.light { background: var(--board-light); }
    .square.dark { background: var(--board-dark); }

    .square.selected {
      background: rgba(255,255,0,0.7) !important;
      box-shadow: inset 0 0 20px rgba(255,255,0,1);
      transform: scale(1.1);
      z-index: 10;
    }

    .square.valid-move {
      background: rgba(0,255,0,0.5) !important;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 0.8; }
    }

    .square.valid-move::after {
      content: "?";
      position: absolute;
      font-size: 30px;
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .piece {
      font-size: min(8vmin, 60px);
      cursor: grab;
      user-select: none;
      filter: drop-shadow(0 0 5px rgba(0,0,0,0.8));
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      position: relative;
      z-index: 5;
      font-family: 'Segoe UI Symbol', 'Arial Unicode MS', sans-serif;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .piece:hover {
      transform: scale(1.3) rotate(5deg);
      filter: drop-shadow(0 0 15px currentColor) drop-shadow(0 0 25px currentColor);
    }

    .piece.dragging {
      transform: scale(1.5) rotate(15deg);
      z-index: 100;
      cursor: grabbing;
    }

    .piece.white {
      color: #fff;
      text-shadow: 0 0 10px rgba(255,255,255,.8);
      background: rgba(255,255,255,0.2); /* Temporary debug background */
      border-radius: 50%;
    }
    .piece.black {
      color: #000;
      text-shadow: 0 0 10px rgba(255,255,255,.3), 2px 2px 0 #fff;
      background: rgba(0,0,0,0.3); /* Temporary debug background */
      border-radius: 50%;
    }

    /* SIDEBAR */
    .sidebar {
      background: rgba(0,0,0,0.8);
      border: 3px solid #ff00ff;
      padding: 20px;
      min-width: 250px;
      max-width: 300px;
      box-shadow:
        0 0 20px rgba(255,0,255,.6),
        inset 0 0 20px rgba(0,255,255,.2);
      position: relative;
      overflow: hidden;
    }

    .sidebar::before {
      content: "";
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255,0,255,.1), transparent);
      animation: shine 3s infinite;
    }

    @keyframes shine {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .status-box {
      position: relative;
      z-index: 1;
      background: rgba(255,0,255,.1);
      padding: 15px;
      border: 2px dashed #00ffff;
      margin-bottom: 15px;
      text-align: center;
    }

    .status-title {
      font-size: 14px;
      color: #00ffff;
      text-transform: uppercase;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #00ffff;
    }

    .status-text {
      font-size: 18px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 0 0 10px #ffff00;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0.5; }
    }

    .captured-box {
      margin: 15px 0;
      padding: 10px;
      background: rgba(0,0,0,.5);
      border: 2px solid #ff00ff;
    }

    .captured-title {
      font-size: 12px;
      color: #ff00ff;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .captured-pieces {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      font-size: 20px;
    }

    button {
      background: linear-gradient(45deg, #ff00ff, #00ffff);
      border: 3px solid #fff;
      color: #000;
      padding: 12px 20px;
      font-size: 16px;
      font-weight: 900;
      text-transform: uppercase;
      cursor: pointer;
      margin: 5px 0;
      width: 100%;
      transition: all 0.2s;
      text-shadow: 1px 1px 0 #fff;
      box-shadow: 0 0 20px rgba(255,0,255,.5);
      position: relative;
      z-index: 1;
    }

    button:hover {
      transform: scale(1.1) rotate(2deg);
      box-shadow: 0 0 30px rgba(255,0,255,.8);
    }

    button:active {
      transform: scale(0.95) rotate(-2deg);
    }

    /* ITALIAN BRAINROT TEXT EFFECTS */
    .dramatic-text {
      position: absolute;
      font-size: 60px;
      font-weight: 900;
      color: #ff00ff;
      text-shadow:
        0 0 20px #ff00ff,
        0 0 40px #ff00ff,
        0 0 60px #00ffff;
      pointer-events: none;
      z-index: 2000;
      animation: dramatic 2s ease-out forwards;
      white-space: nowrap;
    }

    @keyframes dramatic {
      0% {
        transform: scale(0) rotate(-180deg);
        opacity: 0;
      }
      50% {
        transform: scale(1.5) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: scale(1) rotate(0deg);
        opacity: 0;
      }
    }

    @media (max-width: 768px) {
      .game-area {
        flex-direction: column;
        align-items: center;
      }

      .board {
        width: 90vmin;
        height: 90vmin;
      }

      .sidebar {
        width: 90%;
        max-width: none;
      }
    }
  </style>
</head>
<body>
  <div class="title-bar">ðŸŽ® CHESS BUT ITALIAN BRAINROT ðŸŽ®</div>

  <div class="container">
    <div class="game-area">
      <div class="board-container">
        <div class="board" id="board"></div>
      </div>

      <div class="sidebar">
        <div class="status-box">
          <div class="status-title">STATO DEL GIOCO</div>
          <div class="status-text" id="status">WHITE TURNS!</div>
        </div>

        <div class="captured-box">
          <div class="captured-title">CAPTURED WHITE:</div>
          <div class="captured-pieces" id="capturedWhite"></div>
        </div>

        <div class="captured-box">
          <div class="captured-title">CAPTURED BLACK:</div>
          <div class="captured-pieces" id="capturedBlack"></div>
        </div>

        <button onclick="resetGame()">RESET GAME ðŸ”„</button>
        <button onclick="toggleSound()" id="soundBtn">ðŸ”Š SOUND: ON</button>
      </div>
    </div>
  </div>

  <script>
    const PIECES = {
      white: {
        king: 'â™”',
        queen: 'â™•',
        rook: 'â™–',
        bishop: 'â™—',
        knight: 'â™˜',
        pawn: 'â™™'
      },
      black: {
        king: 'â™š',
        queen: 'â™›',
        rook: 'â™œ',
        bishop: 'â™',
        knight: 'â™ž',
        pawn: 'â™Ÿ'
      }
    };

    let board = Array(8).fill(null).map(() => Array(8).fill(null));
    let currentPlayer = 'white';
    let selectedSquare = null;
    let gameOver = false;
    let soundEnabled = true;
    let capturedWhite = [];
    let capturedBlack = [];
    let audioContext;

    function initAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      } catch(e) {}
    }

    function playSound(freq, type = 'sine', duration = 0.2, vol = 0.3) {
      if (!soundEnabled || !audioContext) return;
      try {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(vol, audioContext.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.start();
        osc.stop(audioContext.currentTime + duration);
      } catch(e) {}
    }

    function playItalianNoise() {
      if (!soundEnabled || !audioContext) return;
      try {
        const t = audioContext.currentTime;
        const osc1 = audioContext.createOscillator();
        const gain1 = audioContext.createGain();
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(200, t);
        osc1.frequency.exponentialRampToValueAtTime(100, t + 0.3);
        gain1.gain.setValueAtTime(0, t);
        gain1.gain.linearRampToValueAtTime(0.4, t + 0.05);
        gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc1.connect(gain1);
        gain1.connect(audioContext.destination);
        osc1.start();
        osc1.stop(t + 0.6);

        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(800, t + 0.1);
        gain2.gain.setValueAtTime(0, t + 0.1);
        gain2.gain.linearRampToValueAtTime(0.2, t + 0.12);
        gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.start(t + 0.1);
        osc2.stop(t + 0.3);
      } catch(e) {}
    }

    function showDramaticText(text) {
      const div = document.createElement('div');
      div.className = 'dramatic-text';
      div.textContent = text;
      div.style.left = '50%';
      div.style.top = '50%';
      div.style.transform = 'translate(-50%, -50%)';
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 2000);
      playItalianNoise();
    }

    function initBoard() {
      console.log('Initializing board...');
      const startPos = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
      ];

      let pieceCount = 0;
      for(let row = 0; row < 8; row++) {
        for(let col = 0; col < 8; col++) {
          const piece = startPos[row][col];
          if(piece) {
            board[row][col] = {
              type: piece.toLowerCase(),
              color: piece === piece.toLowerCase() ? 'black' : 'white',
              hasMoved: false
            };
            pieceCount++;
            console.log('Added piece at', row, col, ':', board[row][col]);
          } else {
            board[row][col] = null;
          }
        }
      }
      console.log('Board initialized with', pieceCount, 'pieces');
      renderBoard();
      updateStatus();
    }

    function renderBoard() {
      const boardElement = document.getElementById('board');
      if (!boardElement) {
        console.error('Board element not found!');
        return;
      }
      boardElement.innerHTML = '';

      console.log('Rendering board...');

      for(let row = 0; row < 8; row++) {
        for(let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
          square.dataset.row = row;
          square.dataset.col = col;
          square.addEventListener('click', onSquareClick);

          const piece = board[row][col];
          if(piece) {
            console.log('Adding piece at', row, col, ':', piece);
            const pieceElement = document.createElement('div');
            pieceElement.className = `piece ${piece.color}`;
            pieceElement.textContent = PIECES[piece.color][piece.type];
            console.log('Piece symbol:', PIECES[piece.color][piece.type]);
            square.appendChild(pieceElement);
          }

          boardElement.appendChild(square);
        }
      }

      console.log('Board rendered with', boardElement.children.length, 'squares');
    }

    function onSquareClick(e) {
      if(gameOver) return;

      const row = parseInt(e.currentTarget.dataset.row);
      const col = parseInt(e.currentTarget.dataset.col);

      if(selectedSquare) {
        // Try to move
        if(isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
          makeMove(selectedSquare.row, selectedSquare.col, row, col);
        }
        clearSelection();
      } else {
        // Select piece
        const piece = board[row][col];
        if(piece && piece.color === currentPlayer) {
          selectedSquare = { row, col };
          highlightSquare(row, col, 'selected');
          showValidMoves(row, col);
          playSound(400, 'square', 0.1);
        }
      }
    }

    function isValidMove(fromRow, fromCol, toRow, toCol) {
      const piece = board[fromRow][fromCol];
      const targetPiece = board[toRow][toCol];

      // Can't capture own pieces
      if(targetPiece && targetPiece.color === piece.color) return false;

      // Basic movement validation (simplified)
      const rowDiff = Math.abs(toRow - fromRow);
      const colDiff = Math.abs(toCol - fromCol);

      switch(piece.type) {
        case 'pawn':
          const direction = piece.color === 'white' ? -1 : 1;
          const startRow = piece.color === 'white' ? 6 : 1;

          if(toCol === fromCol && !targetPiece) {
            // Forward move
            if(toRow === fromRow + direction) return true;
            // Double move from start
            if(fromRow === startRow && toRow === fromRow + 2 * direction) return true;
          } else if(Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction && targetPiece) {
            // Diagonal capture
            return true;
          }
          return false;

        case 'rook':
          return (fromRow === toRow || fromCol === toCol) && isPathClear(fromRow, fromCol, toRow, toCol);

        case 'bishop':
          return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);

        case 'queen':
          return ((fromRow === toRow || fromCol === toCol) || rowDiff === colDiff) && isPathClear(fromRow, fromCol, toRow, toCol);

        case 'knight':
          return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

        case 'king':
          return rowDiff <= 1 && colDiff <= 1;

        default:
          return false;
      }
    }

    function isPathClear(fromRow, fromCol, toRow, toCol) {
      const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
      const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

      let currentRow = fromRow + rowStep;
      let currentCol = fromCol + colStep;

      while(currentRow !== toRow || currentCol !== toCol) {
        if(board[currentRow][currentCol]) return false;
        currentRow += rowStep;
        currentCol += colStep;
      }

      return true;
    }

    function makeMove(fromRow, fromCol, toRow, toCol) {
      const piece = board[fromRow][fromCol];
      const capturedPiece = board[toRow][toCol];

      // Capture piece
      if(capturedPiece) {
        if(capturedPiece.color === 'white') {
          capturedWhite.push(PIECES[capturedPiece.color][capturedPiece.type]);
        } else {
          capturedBlack.push(PIECES[capturedPiece.color][capturedPiece.type]);
        }
        updateCapturedPieces();
        showDramaticText('CAPTURE!');
      }

      // Move piece
      board[toRow][toCol] = piece;
      board[fromRow][fromCol] = null;
      piece.hasMoved = true;

      // Check for pawn promotion
      if(piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
        piece.type = 'queen';
        showDramaticText('PROMOTION!');
      }

      currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
      renderBoard();
      updateStatus();
      playSound(600, 'triangle', 0.3);
    }

    function showValidMoves(row, col) {
      for(let r = 0; r < 8; r++) {
        for(let c = 0; c < 8; c++) {
          if(isValidMove(row, col, r, c)) {
            highlightSquare(r, c, 'valid-move');
          }
        }
      }
    }

    function highlightSquare(row, col, className) {
      const squares = document.querySelectorAll('.square');
      const index = row * 8 + col;
      squares[index].classList.add(className);
    }

    function clearSelection() {
      selectedSquare = null;
      document.querySelectorAll('.square').forEach(square => {
        square.classList.remove('selected', 'valid-move');
      });
    }

    function updateStatus() {
      const statusElement = document.getElementById('status');
      if(gameOver) {
        statusElement.textContent = 'GAME OVER!';
      } else {
        statusElement.textContent = `${currentPlayer.toUpperCase()} TURNS!`;
      }
    }

    function updateCapturedPieces() {
      document.getElementById('capturedWhite').textContent = capturedWhite.join(' ');
      document.getElementById('capturedBlack').textContent = capturedBlack.join(' ');
    }

    function resetGame() {
      board = Array(8).fill(null).map(() => Array(8).fill(null));
      currentPlayer = 'white';
      selectedSquare = null;
      gameOver = false;
      capturedWhite = [];
      capturedBlack = [];
      initBoard();
      updateCapturedPieces();
      showDramaticText('RESET!');
    }

    function toggleSound() {
      soundEnabled = !soundEnabled;
      const btn = document.getElementById('soundBtn');
      btn.textContent = `ðŸ”Š SOUND: ${soundEnabled ? 'ON' : 'OFF'}`;
      if(soundEnabled) {
        playSound(800, 'sawtooth', 0.2);
      }
    }

    // Initialize game
    initAudio();
    initBoard();
  </script>
</body>
</html>
