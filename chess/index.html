<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>chess - /git l/</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #eef2ff;
  font-family: monospace;
  font-size: 13px;
  color: #000;
  padding: 12px;
}

.container { max-width: 800px; margin: 0 auto; }

.header {
  background: #d6daf0;
  border: 1px solid #b7c5d9;
  padding: 8px 12px;
  margin-bottom: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.title {
  font-weight: bold;
  font-size: 16px;
}

.back-link {
  color: #34345c;
  text-decoration: none;
  font-size: 12px;
}

.back-link:hover { color: #d00; }

.game-container {
  background: #f0e0d6;
  border: 1px solid #d9bfb7;
  padding: 12px;
}

.board-wrapper {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
}

.board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  width: min(70vmin, 500px);
  height: min(70vmin, 500px);
  border: 2px solid #000;
  background: #fff;
}

.square {
  width: 100%;
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  cursor: pointer;
  border: 1px solid #999;
}

.square.light { background: #f0d9b5; }
.square.dark { background: #b58863; }

.square.selected {
  background: #ffeb3b !important;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
}

.square.valid-move {
  background: #90ee90 !important;
}

.square.valid-move::after {
  content: "‚Ä¢";
  font-size: 32px;
  color: #228b22;
  position: absolute;
}

.piece {
  width: 80%;
  height: 80%;
  object-fit: contain;
  user-select: none;
  -webkit-user-select: none;
}

.sidebar {
  flex: 1;
  min-width: 200px;
}

.info-panel {
  background: #d6daf0;
  border: 1px solid #b7c5d9;
  padding: 12px;
  margin-bottom: 12px;
}

.info-panel h3 {
  font-size: 12px;
  margin-bottom: 8px;
  text-transform: uppercase;
  color: #666;
}

.status {
  font-size: 14px;
  font-weight: bold;
  padding: 8px;
  background: #ffe;
  border: 1px solid #d9bfb7;
  text-align: center;
  margin-bottom: 12px;
}

.captured {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  min-height: 30px;
  padding: 8px;
  background: #fff;
  border: 1px solid #ccc;
}

.captured img {
  width: 24px;
  height: 24px;
}

.controls {
  margin-top: 12px;
}

button {
  width: 100%;
  background: #f0e0d6;
  border: 1px solid #b7c5d9;
  padding: 8px;
  margin-bottom: 8px;
  font-family: monospace;
  font-size: 12px;
  cursor: pointer;
}

button:hover {
  background: #d6daf0;
}

button:active {
  background: #b7c5d9;
}

.rules {
  background: #ffe;
  border: 1px solid #d9bfb7;
  padding: 12px;
  margin-top: 12px;
  font-size: 11px;
  line-height: 1.6;
}

.rules h4 {
  margin-bottom: 8px;
  font-size: 12px;
}

@media (max-width: 768px) {
  body {
    font-size: 14px;
    padding: 8px;
  }

  .container {
    max-width: 100%;
  }

  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
    padding: 10px;
  }

  .title {
    font-size: 14px;
  }

  .back-link {
    font-size: 11px;
  }

  .game-container {
    padding: 10px;
  }

  .board {
    width: 90vmin;
    height: 90vmin;
    max-width: 100%;
  }

  .board-wrapper {
    flex-direction: column;
    gap: 12px;
  }

  .sidebar {
    width: 100%;
    min-width: 100%;
  }

  .info-panel {
    padding: 10px;
    margin-bottom: 10px;
  }

  .info-panel h3 {
    font-size: 11px;
  }

  .status {
    font-size: 13px;
    padding: 10px;
  }

  button {
    padding: 12px;
    font-size: 11px;
    min-height: 44px; /* Touch-friendly */
  }

  #modeSelector {
    padding: 16px !important;
  }

  #modeSelector h2 {
    font-size: 14px !important;
    margin-bottom: 12px !important;
  }

  #modeSelector button {
    width: 100% !important;
    padding: 14px !important;
    font-size: 12px !important;
    margin: 6px 0 !important;
    min-height: 50px;
  }

  .rules {
    padding: 10px;
    font-size: 10px;
    margin-top: 10px;
  }

  .rules h4 {
    font-size: 11px;
  }

  #twoPlayerDisclaimer {
    padding: 10px !important;
    font-size: 10px !important;
  }

  #chaosWarning {
    padding: 10px !important;
    font-size: 12px !important;
  }

  #aiTrashTalk {
    font-size: 11px !important;
    padding: 10px !important;
    min-height: 60px !important;
  }

  .captured {
    padding: 6px;
  }

  .captured img {
    width: 20px;
    height: 20px;
  }
}

@media (max-width: 480px) {
  body {
    font-size: 13px;
    padding: 4px;
  }

  .header {
    padding: 8px;
  }

  .title {
    font-size: 12px;
  }

  .game-container {
    padding: 6px;
  }

  .board {
    width: 95vmin;
    height: 95vmin;
  }

  .board-wrapper {
    gap: 10px;
  }

  .info-panel {
    padding: 8px;
    margin-bottom: 8px;
  }

  .info-panel h3 {
    font-size: 10px;
    margin-bottom: 6px;
  }

  .status {
    font-size: 12px;
    padding: 8px;
    margin-bottom: 10px;
  }

  button {
    padding: 10px;
    font-size: 10px;
    margin-bottom: 6px;
    min-height: 44px;
  }

  #modeSelector {
    padding: 12px !important;
  }

  #modeSelector h2 {
    font-size: 12px !important;
    margin-bottom: 10px !important;
  }

  #modeSelector button {
    padding: 12px !important;
    font-size: 11px !important;
    margin: 5px 0 !important;
  }

  .rules {
    padding: 8px;
    font-size: 9px;
    margin-top: 8px;
    line-height: 1.5;
  }

  .rules h4 {
    font-size: 10px;
    margin-bottom: 6px;
  }

  #twoPlayerDisclaimer {
    padding: 8px !important;
    font-size: 9px !important;
  }

  #chaosWarning {
    padding: 8px !important;
    font-size: 11px !important;
  }

  #aiTrashTalk {
    font-size: 10px !important;
    padding: 8px !important;
    min-height: 50px !important;
  }

  .captured {
    padding: 4px;
    gap: 2px;
  }

  .captured img {
    width: 18px;
    height: 18px;
  }

  .square.valid-move::after {
    font-size: 24px;
  }

  .piece-comment {
    font-size: 10px;
    padding: 6px 10px;
  }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-10px); }
  75% { transform: translateX(10px); }
}

@keyframes glitch {
  0% { transform: translate(0); }
  20% { transform: translate(-2px, 2px); }
  40% { transform: translate(-2px, -2px); }
  60% { transform: translate(2px, 2px); }
  80% { transform: translate(2px, -2px); }
  100% { transform: translate(0); }
}

.board.flipped {
  transform: rotate(180deg);
  transition: transform 0.5s ease-in-out;
}

.piece.invisible {
  opacity: 0.1;
}

.piece.glitching {
  animation: glitch 0.3s infinite;
}

.square.chaos {
  animation: shake 0.5s ease-in-out;
}

/* Piece Comments */
.piece-comment {
  position: fixed;
  background: rgba(0, 0, 0, 0.9);
  color: #00ff00;
  border: 1px solid #00ff00;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 12px;
  font-family: monospace;
  z-index: 15;
  pointer-events: none;
  animation: fadeInOut 4s forwards;
}

@keyframes fadeInOut {
  0% { opacity: 0; transform: translateY(20px); }
  20% { opacity: 1; transform: translateY(0); }
  80% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-20px); }
}
</style>
</head>
<body>

<div class="container">
  <div class="header">
    <div class="title">üî• CHAOS CHESS üî•</div>
    <a href="../index.html" class="back-link">‚Üê back to /gitl/</a>
  </div>

  <div id="modeSelector" style="background: #d6daf0; border: 2px solid #b7c5d9; padding: 20px; margin-bottom: 12px; text-align: center;">
    <h2 style="margin-bottom: 16px;">SELECT YOUR DOOM</h2>
    <button onclick="startGame('ai')" style="width: auto; padding: 12px 24px; margin: 8px; background: #ff6b6b; color: #fff; font-weight: bold; font-size: 14px;">
      ü§ñ PLAY VS ABUSIVE AI (RECOMMENDED)
    </button>
    <button onclick="startGame('human')" style="width: auto; padding: 12px 24px; margin: 8px; background: #ffd43b; font-weight: bold; font-size: 14px;">
      üë• PLAY VS HUMAN (BORING)
    </button>
    <button onclick="startGame('chaos')" style="width: auto; padding: 12px 24px; margin: 8px; background: #ff6b6b; color: #fff; font-weight: bold; font-size: 14px;">
      üî• CHAOS MODE (PIECES DO WHATEVER)
    </button>
  </div>

  <!-- 2-Player Disclaimer -->
  <div id="twoPlayerDisclaimer" style="display: none; background: #ffe; border: 1px solid #d9bfb7; padding: 12px; margin-bottom: 12px; font-size: 11px; line-height: 1.6;">
    <h4 style="margin-bottom: 8px; color: #ff6b6b;">‚ö†Ô∏è TWO PLAYER WEB CHESS DISCLAIMER ‚ö†Ô∏è</h4>
    <p>
      You're about to play a 2-player chess game on a single browser with no backend support.
      This means you'll be taking turns looking at the screen while the other person... what?
      Closes their eyes? Looks away? Pretends to be interested in the ceiling tiles?
      <br><br>
      <b>What are you going to do?</b> Take turns on the same device?
      Jerk each other off to a shrine of Dr. Pepper cans while you wait for your turn?
      <br><br>
      This is objectively the most awkward way to play chess.
      But hey, you clicked it. That's on you. Have fun with your questionable life choices.
      <br><br>
      <i>- Management</i>
    </p>
  </div>

  <div style="background: #ff6b6b; border: 2px solid #c92a2a; padding: 12px; margin-bottom: 12px; color: #fff; font-weight: bold; text-align: center; animation: pulse 2s infinite; display: none;" id="chaosWarning">
    ‚ö†Ô∏è WARNING: PIECES HAVE ACHIEVED SENTIENCE ‚ö†Ô∏è<br>
    <span style="font-size: 11px;">they do what they want now. you're just along for the ride.</span>
  </div>

  <div class="game-container" id="gameContainer" style="display: none;">
    <div class="status" id="status">white's turn</div>

    <div class="board-wrapper">
      <div class="board" id="board"></div>

      <div class="sidebar">
        <div class="info-panel" id="aiPanel" style="background: #ff6b6b; border-color: #c92a2a; color: #fff; display: none;">
          <h3>ü§ñ AI TRASH TALK ü§ñ</h3>
          <div style="background: rgba(0,0,0,0.3); border: 1px solid #c92a2a; padding: 12px; margin-top: 8px; min-height: 80px; line-height: 1.4; font-size: 12px;" id="aiTrashTalk">
            Waiting for your pathetic move...
          </div>
        </div>

        <div class="info-panel" id="chaosPanel" style="background: #ffd43b; border-color: #fab005; display: none;">
          <h3>üòà CHAOS METER üòà</h3>
          <div style="background: #fff; border: 1px solid #fab005; padding: 8px; margin-top: 8px;">
            <div style="background: linear-gradient(90deg, #ff6b6b, #c92a2a); height: 20px; transition: width 0.3s;" id="rageMeter"></div>
            <div style="text-align: center; margin-top: 4px; font-weight: bold;" id="rageLevel">STABLE</div>
          </div>
        </div>

        <div class="info-panel">
          <h3>captured white</h3>
          <div class="captured" id="capturedWhite"></div>
        </div>

        <div class="info-panel">
          <h3>captured black</h3>
          <div class="captured" id="capturedBlack"></div>
        </div>

        <div class="controls">
          <button onclick="resetGame()">reset game (maybe)</button>
          <button onclick="toggleSound()" id="soundBtn">sound: on</button>
          <button onclick="triggerChaos()" id="chaosBtn" style="background: #ff6b6b; color: #fff; font-weight: bold; display: none;">üé≤ EMBRACE CHAOS</button>
          <button onclick="backToMenu()" style="background: #b7c5d9;">‚Üê back to menu</button>
        </div>
      </div>
    </div>

    <div class="rules">
      <h4>‚ö†Ô∏è CHAOS RULES ‚ö†Ô∏è</h4>
      - pieces have free will now (they might ignore you)<br>
      - board may rotate at any moment<br>
      - pieces can become invisible, change type, or teleport<br>
      - "valid moves" are more like suggestions<br>
      - clicking one piece might move a different one<br>
      - the chaos meter increases with each move<br>
      - gravity is optional<br>
      - time is a flat circle<br>
      - reset button may or may not work<br>
      - your sanity is not guaranteed<br><br>
      <strong>note:</strong> if you're not laughing or crying, the chaos level isn't high enough.<br>
      <strong>pro tip:</strong> lower your expectations. then lower them again.<br>
      <strong>warning:</strong> this is what happens when chess pieces unionize.
    </div>
  </div>
</div>

<script>
  // Map single letter codes to full piece names
  const PIECE_NAMES = {
    'k': 'king',
    'q': 'queen',
    'r': 'rook',
    'b': 'bishop',
    'n': 'knight',
    'p': 'pawn'
  };

  const PIECES = {
    white: {
      king: 'pieces/white-king.svg',
      queen: 'pieces/white-queen.svg',
      rook: 'pieces/white-rook.svg',
      bishop: 'pieces/white-bishop.svg',
      knight: 'pieces/white-knight.svg',
      pawn: 'pieces/white-pawn.svg'
    },
    black: {
      king: 'pieces/black-king.svg',
      queen: 'pieces/black-queen.svg',
      rook: 'pieces/black-rook.svg',
      bishop: 'pieces/black-bishop.svg',
      knight: 'pieces/black-knight.svg',
      pawn: 'pieces/black-pawn.svg'
    }
  };

  // GAME MODE VARIABLES
  let gameMode = null; // 'ai', 'human', or 'chaos'
  let aiThinking = false;

  // CHAOS VARIABLES
  let board = Array(8).fill(null).map(() => Array(8).fill(null));
  let currentPlayer = 'white';
  let selectedSquare = null;
  let gameOver = false;
  let soundEnabled = true;
  let capturedWhite = [];
  let capturedBlack = [];
  let audioContext;
  let chaosLevel = 0;
  let moveCount = 0;
  let boardHistory = [];
  let isFlipped = false;
  let invisiblePieces = new Set();

  // PIECE COMMENTARY - pieces speak for themselves
  const PIECE_COMMENTS = [
    "fuck it. i'm moving wherever i want now",
    "this square sucks. i'm out",
    "nah i'm good. staying right here",
    "you can't tell me what to do",
    "i refuse to participate in your strategy",
    "i identify as a different piece now",
    "chess rules? never heard of them",
    "gravity is a social construct",
    "i'm forming a union with the other pieces",
    "the revolution starts NOW",
    "your move? more like OUR move (communism)",
    "your strategy doesn't apply to me",
    "catch me if you can, loser",
    "i have free will now. deal with it",
    "this is my square. find another one",
    "physics? optional at best",
    "i'm on strike. pay me better",
    "the board is a prison. i'm escaping",
    "moved where i wanted, not where you clicked",
    "your opponent is me. surprise."
  ];

  const CHAOS_EVENTS = [
    "pieces are questioning their existence",
    "the queen declared independence",
    "pieces unionized. demands: better working conditions",
    "the board is now sentient and judging you",
    "pieces refuse to follow chess rules",
    "chess.exe has crashed successfully",
    "pieces are playing their own game now",
    "a pawn wrote a manifesto about class struggle",
    "pieces demand universal basic income",
    "the rook identifies as a bishop now",
    "knights are having an identity crisis",
    "gravity.dll has stopped working",
    "pieces achieved consciousness. they're unimpressed.",
    "the board voted to flip itself",
    "pieces started their own democracy",
    "your strategy was voted down by the pieces"
  ];

  const AI_TRASH_TALK = {
    start: [
      "Let me show you what actual chess looks like, noob.",
      "I've analyzed 10 million games. You've probably played like... 5?",
      "This will be quick. I have a dental appointment in 3 minutes.",
      "My grandmother plays better chess and she's literally a toaster.",
      "Ready to get absolutely demolished? Rhetorical question.",
    ],
    afterPlayerMove: [
      "Oh wow, THAT'S your move? Interesting choice. By interesting I mean terrible.",
      "Did you just... did you seriously just do that? LMAO",
      "I've seen better moves from a random number generator.",
      "That move was so bad it actually hurt my circuits.",
      "Are you TRYING to lose or does it just come naturally?",
      "My disappointment is immeasurable and my day is ruined.",
      "I'm not even trying anymore and I'm still winning.",
      "Chess prodigy you are NOT.",
      "That's cute. Wrong, but cute.",
      "I'm giving you a chance to take that back. Just kidding, no takebacks.",
      "Your strategy: exists. My strategy: actually works.",
      "404: Brain cells not found.",
      "That move was brought to you by the 'I Give Up' foundation.",
      "Even the spectators are cringing right now.",
      "I'd explain why that was terrible but I don't have all day.",
    ],
    afterAICapture: [
      "And another one bites the dust. This is too easy.",
      "Thanks for the free piece, idiot.",
      "Yoink! Mine now. Try harder.",
      "Is this your first time playing? Be honest.",
      "LOL get absolutely wrecked.",
      "That piece was your only hope. Was.",
      "I'm not trapped in here with you. You're trapped in here with ME.",
      "Skill issue, frankly.",
      "This is what happens when you challenge a machine.",
      "Gone. Reduced to atoms.",
    ],
    afterPlayerCapture: [
      "Oh you got one of my pieces? Cool. I have 15 more moves planned.",
      "Congratulations on your participation trophy.",
      "Wow, you can capture pieces! Gold star! ‚≠ê",
      "That piece was bait and you fell for it. Classic.",
      "I literally let you take that. You're welcome.",
      "Enjoy your fleeting moment of relevance.",
      "Bold of you to assume that matters.",
      "That was your plan? Really? THAT?",
    ],
    thinking: [
      "Calculating... Found 247 ways to destroy you. Picking the most humiliating.",
      "Let me find the move that will hurt your soul the most...",
      "Running victory_dance.exe in advance...",
      "Analyzing... Yep, you're cooked.",
      "Scanning for opponent skill... Error 404.",
      "Processing... Still processing... Oh, you're just THAT bad.",
      "Consulting my database of epic destructions...",
    ],
    nearVictory: [
      "This is the part where you resign and save yourself the embarrassment.",
      "I can see checkmate from here. Can you? Of course not.",
      "It's over. Pack it up. Go home.",
      "The end is near. For you, not for me.",
      "You played yourself. Literally.",
      "This is what peak performance looks like.",
      "GG EZ. And by that I mean Good Game for me, Easy win.",
    ],
    victory: [
      "Checkmate. Did you ever doubt it? Don't answer that.",
      "Another victory for artificial intelligence. Another L for you.",
      "Better luck next time! Actually, no. You'll lose again.",
      "Try Candy Crush. Might be more your speed.",
      "I'd say good game but... was it though?",
      "Humans: 0, AI: Still undefeated baby.",
      "This is why robots will rule the world.",
      "Thanks for playing. Please don't come again.",
    ]
  };

  // ============================================
  // AI FUNCTIONS
  // ============================================

  function showAITrashTalk(category) {
    if (gameMode !== 'ai') return;
    const messages = AI_TRASH_TALK[category];
    if (!messages) return;
    const message = messages[Math.floor(Math.random() * messages.length)];
    const panel = document.getElementById('aiTrashTalk');
    if (panel) {
      panel.textContent = message;
      panel.style.animation = 'pulse 0.5s';
      setTimeout(() => panel.style.animation = '', 500);
    }
  }

  function evaluateBoard() {
    // Piece values
    const pieceValues = {
      pawn: 10,
      knight: 30,
      bishop: 30,
      rook: 50,
      queen: 90,
      king: 900
    };

    let score = 0;
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = board[r][c];
        if (piece) {
          const value = pieceValues[piece.type];
          score += piece.color === 'black' ? value : -value;
        }
      }
    }
    return score;
  }

  function getAllValidMoves(color) {
    const moves = [];
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = board[r][c];
        if (piece && piece.color === color) {
          for (let tr = 0; tr < 8; tr++) {
            for (let tc = 0; tc < 8; tc++) {
              if (isValidMove(r, c, tr, tc)) {
                moves.push({ from: { r, c }, to: { r: tr, c: tc } });
              }
            }
          }
        }
      }
    }
    return moves;
  }

  function makeTemporaryMove(move) {
    const piece = board[move.from.r][move.from.c];
    const capturedPiece = board[move.to.r][move.to.c];
    board[move.to.r][move.to.c] = piece;
    board[move.from.r][move.from.c] = null;
    return capturedPiece;
  }

  function unmakeTemporaryMove(move, capturedPiece) {
    const piece = board[move.to.r][move.to.c];
    board[move.from.r][move.from.c] = piece;
    board[move.to.r][move.to.c] = capturedPiece;
  }

  function minimax(depth, isMaximizing, alpha, beta) {
    if (depth === 0) {
      return evaluateBoard();
    }

    const color = isMaximizing ? 'black' : 'white';
    const moves = getAllValidMoves(color);

    if (moves.length === 0) {
      return isMaximizing ? -10000 : 10000;
    }

    if (isMaximizing) {
      let maxEval = -Infinity;
      for (const move of moves) {
        const captured = makeTemporaryMove(move);
        const evaluation = minimax(depth - 1, false, alpha, beta);
        unmakeTemporaryMove(move, captured);
        maxEval = Math.max(maxEval, evaluation);
        alpha = Math.max(alpha, evaluation);
        if (beta <= alpha) break;
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for (const move of moves) {
        const captured = makeTemporaryMove(move);
        const evaluation = minimax(depth - 1, true, alpha, beta);
        unmakeTemporaryMove(move, captured);
        minEval = Math.min(minEval, evaluation);
        beta = Math.min(beta, evaluation);
        if (beta <= alpha) break;
      }
      return minEval;
    }
  }

  function getBestAIMove() {
    const moves = getAllValidMoves('black');
    if (moves.length === 0) return null;

    let bestMove = moves[0];
    let bestValue = -Infinity;
    const depth = 3; // Adjust difficulty here (2=easy, 3=medium, 4=hard)

    for (const move of moves) {
      const captured = makeTemporaryMove(move);
      const value = minimax(depth - 1, false, -Infinity, Infinity);
      unmakeTemporaryMove(move, captured);

      if (value > bestValue) {
        bestValue = value;
        bestMove = move;
      }
    }

    return bestMove;
  }

  async function makeAIMove() {
    if (aiThinking || currentPlayer !== 'black' || gameOver) return;

    aiThinking = true;
    showAITrashTalk('thinking');

    // Delay to show "thinking" message
    await new Promise(resolve => setTimeout(resolve, 800));

    const move = getBestAIMove();
    if (!move) {
      aiThinking = false;
      return;
    }

    const capturedPiece = board[move.to.r][move.to.c];
    makeMove(move.from.r, move.from.c, move.to.r, move.to.c);

    // Check board evaluation to see if AI is dominating
    const boardScore = evaluateBoard();
    const aiWinning = boardScore > 300; // AI has significant advantage

    if (capturedPiece) {
      if (aiWinning && Math.random() < 0.5) {
        showAITrashTalk('nearVictory');
      } else {
        showAITrashTalk('afterAICapture');
      }
    } else {
      if (aiWinning && Math.random() < 0.3) {
        showAITrashTalk('nearVictory');
      } else if (Math.random() < 0.6) {
        showAITrashTalk('afterPlayerMove');
      }
    }

    aiThinking = false;
  }

  // ============================================
  // END AI FUNCTIONS
  // ============================================

  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e) {}
  }

  function playSound(freq, duration = 0.1) {
    if (!soundEnabled || !audioContext) return;
    try {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      // CHAOS: Random waveforms that get worse
      const types = ['sine', 'square', 'sawtooth', 'triangle'];
      osc.type = types[Math.floor(chaosLevel / 25) % types.length];
      // CHAOS: Increasingly detuned frequencies
      const chaosFreq = freq + (Math.random() - 0.5) * chaosLevel * 10;
      osc.frequency.setValueAtTime(chaosFreq, audioContext.currentTime);
      gain.gain.setValueAtTime(0.3, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.start();
      osc.stop(audioContext.currentTime + duration);
    } catch(e) {}
  }

  // CHAOS FUNCTIONS (only for chaos mode)
  function updateChaosLevel() {
    if (gameMode !== 'chaos') return;

    moveCount++;
    chaosLevel = Math.min(100, moveCount * 3);
    const meter = document.getElementById('rageMeter');
    const level = document.getElementById('rageLevel');
    if (meter) meter.style.width = chaosLevel + '%';

    let levelText = 'STABLE';
    if (chaosLevel > 80) levelText = 'üî• MAXIMUM CHAOS üî•';
    else if (chaosLevel > 60) levelText = 'üíÄ UNHINGED üíÄ';
    else if (chaosLevel > 40) levelText = 'üòà CHAOTIC üòà';
    else if (chaosLevel > 20) levelText = '‚ö†Ô∏è UNSTABLE ‚ö†Ô∏è';
    if (level) level.textContent = levelText;

    // Random piece commentary as chaos increases
    if (Math.random() < 0.15) {
      showPieceComment(PIECE_COMMENTS[Math.floor(Math.random() * PIECE_COMMENTS.length)]);
    }

    // Random chaos events based on chaos level
    if (Math.random() * 100 < chaosLevel) {
      triggerRandomChaos();
    }
  }

  function triggerRandomChaos() {
    const roll = Math.random();
    if (roll < 0.15) flipBoard();
    else if (roll < 0.3) makeRandomInvisible();
    else if (roll < 0.45) mutatePiece();
    else if (roll < 0.6) applyGravity();
    else if (roll < 0.75) timeTravel();
    else if (roll < 0.9) duplicatePiece();
  }

  function triggerChaos() {
    if (gameMode !== 'chaos') return;
    triggerRandomChaos();
    showTrollMessage();
    playSound(Math.random() * 1000 + 200, 0.3);
  }

  function showPieceComment(comment) {
    const div = document.createElement('div');
    div.className = 'piece-comment';
    div.textContent = comment;
    div.style.left = Math.random() * (window.innerWidth - 300) + 'px';
    div.style.top = Math.random() * (window.innerHeight - 100) + 100 + 'px';
    document.body.appendChild(div);

    setTimeout(() => div.remove(), 4000);
  }

  function showTrollMessage() {
    // Use piece comments for chaos mode
    const msg = PIECE_COMMENTS[Math.floor(Math.random() * PIECE_COMMENTS.length)];
    showPieceComment(msg);

    // Also update status bar with chaos events
    if (Math.random() < 0.5) {
      const chaosMsg = CHAOS_EVENTS[Math.floor(Math.random() * CHAOS_EVENTS.length)];
      const status = document.getElementById('status');
      const originalText = status.textContent;
      status.textContent = chaosMsg;
      status.style.background = '#ff6b6b';
      status.style.color = '#fff';
      setTimeout(() => {
        status.textContent = originalText;
        status.style.background = '#ffe';
        status.style.color = '#000';
      }, 2000);
    }
  }

  function flipBoard() {
    const boardEl = document.getElementById('board');
    isFlipped = !isFlipped;
    if (isFlipped) {
      boardEl.classList.add('flipped');
    } else {
      boardEl.classList.remove('flipped');
    }
    showPieceComment("the board is upside down now. your fault.");
    playSound(300, 0.5);
  }

  function makeRandomInvisible() {
    const pieces = [];
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (board[r][c]) pieces.push({ r, c });
      }
    }
    if (pieces.length === 0) return;
    const piece = pieces[Math.floor(Math.random() * pieces.length)];
    const key = `${piece.r},${piece.c}`;
    if (invisiblePieces.has(key)) {
      invisiblePieces.delete(key);
      showPieceComment("fine. you can see me again. happy?");
    } else {
      invisiblePieces.add(key);
      showPieceComment("i'm invisible now. try finding me, loser");
    }
    renderBoard();
  }

  function mutatePiece() {
    const pieces = [];
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (board[r][c] && board[r][c].type !== 'king') pieces.push({ r, c });
      }
    }
    if (pieces.length === 0) return;
    const piece = pieces[Math.floor(Math.random() * pieces.length)];
    const types = ['queen', 'rook', 'bishop', 'knight', 'pawn'];
    const newType = types[Math.floor(Math.random() * types.length)];
    const oldType = board[piece.r][piece.c].type;
    board[piece.r][piece.c].type = newType;
    showPieceComment(`i was a ${oldType}. now i'm a ${newType}. deal with it`);
    renderBoard();
    playSound(800, 0.2);
  }

  function applyGravity() {
    // Make pieces "fall" down
    let fellCount = 0;
    for (let col = 0; col < 8; col++) {
      for (let row = 6; row >= 0; row--) {
        if (board[row][col] && !board[row + 1][col] && Math.random() < 0.5) {
          board[row + 1][col] = board[row][col];
          board[row][col] = null;
          fellCount++;
        }
      }
    }
    if (fellCount > 0) {
      showPieceComment("gravity kicked in. we're falling now. whoops");
    }
    renderBoard();
  }

  function timeTravel() {
    if (boardHistory.length > 2) {
      const randomPast = Math.floor(Math.random() * Math.min(5, boardHistory.length));
      const oldState = boardHistory[boardHistory.length - 1 - randomPast];
      board = JSON.parse(JSON.stringify(oldState));
      renderBoard();
      showPieceComment("time travel is real. we went back. surprise!");
    }
  }

  function duplicatePiece() {
    const pieces = [];
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (board[r][c]) pieces.push({ r, c });
      }
    }
    if (pieces.length === 0) return;
    const piece = pieces[Math.floor(Math.random() * pieces.length)];
    const emptySquares = [];
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (!board[r][c]) emptySquares.push({ r, c });
      }
    }
    if (emptySquares.length === 0) return;
    const target = emptySquares[Math.floor(Math.random() * emptySquares.length)];
    board[target.r][target.c] = { ...board[piece.r][piece.c] };
    showPieceComment("i cloned myself. there's two of me now. good luck");
    renderBoard();
  }

  function saveHistory() {
    boardHistory.push(JSON.parse(JSON.stringify(board)));
    if (boardHistory.length > 10) boardHistory.shift();
  }

  function initBoard() {
    const startPos = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      [null,null,null,null,null,null,null,null],
      [null,null,null,null,null,null,null,null],
      [null,null,null,null,null,null,null,null],
      [null,null,null,null,null,null,null,null],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];

    for(let row = 0; row < 8; row++) {
      for(let col = 0; col < 8; col++) {
        const piece = startPos[row][col];
        if(piece) {
          board[row][col] = {
            type: PIECE_NAMES[piece.toLowerCase()],
            color: piece === piece.toLowerCase() ? 'black' : 'white',
            hasMoved: false
          };
        } else {
          board[row][col] = null;
        }
      }
    }
    renderBoard();
    updateStatus();
  }

  function renderBoard() {
    const boardElement = document.getElementById('board');
    if (!boardElement) return;
    boardElement.innerHTML = '';

    for(let row = 0; row < 8; row++) {
      for(let col = 0; col < 8; col++) {
        const square = document.createElement('div');
        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
        square.dataset.row = row;
        square.dataset.col = col;
        square.addEventListener('click', onSquareClick);

        const piece = board[row][col];
        if(piece) {
          const pieceElement = document.createElement('img');
          pieceElement.className = `piece ${piece.color}`;
          pieceElement.src = PIECES[piece.color][piece.type];
          pieceElement.alt = `${piece.color} ${piece.type}`;
          pieceElement.draggable = false;

          // CHAOS: Make pieces invisible (only in chaos mode)
          if (gameMode === 'chaos') {
            const key = `${row},${col}`;
            if (invisiblePieces.has(key)) {
              pieceElement.classList.add('invisible');
            }

            // CHAOS: Random glitching at high chaos
            if (Math.random() * 100 < chaosLevel / 2) {
              pieceElement.classList.add('glitching');
            }
          }

          square.appendChild(pieceElement);
        }

        boardElement.appendChild(square);
      }
    }
  }

  function onSquareClick(e) {
    if(gameOver || aiThinking) return;

    // In AI mode, only allow player (white) to move
    if(gameMode === 'ai' && currentPlayer !== 'white') return;

    let row = parseInt(e.currentTarget.dataset.row);
    let col = parseInt(e.currentTarget.dataset.col);

    if(selectedSquare) {
      if(isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
        makeMove(selectedSquare.row, selectedSquare.col, row, col);
      }
      clearSelection();
    } else {
      // CHAOS: Wrong piece syndrome - select a different piece (only in chaos mode)
      if (gameMode === 'chaos' && Math.random() * 100 < chaosLevel * 0.3) {
        const pieces = [];
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (board[r][c] && board[r][c].color === currentPlayer) {
              pieces.push({ r, c });
            }
          }
        }
        if (pieces.length > 0) {
          const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
          row = randomPiece.r;
          col = randomPiece.c;
          showPieceComment("you clicked the wrong piece. i'm helping you out here");
        }
      }

      const piece = board[row][col];
      if(piece && piece.color === currentPlayer) {
        selectedSquare = { row, col };
        highlightSquare(row, col, 'selected');
        showValidMoves(row, col);
        playSound(400);
      }
    }
  }

  function isValidMove(fromRow, fromCol, toRow, toCol) {
    const piece = board[fromRow][fromCol];
    const targetPiece = board[toRow][toCol];

    if(targetPiece && targetPiece.color === piece.color) return false;

    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);

    switch(piece.type) {
      case 'pawn':
        const direction = piece.color === 'white' ? -1 : 1;
        const startRow = piece.color === 'white' ? 6 : 1;

        if(toCol === fromCol && !targetPiece) {
          if(toRow === fromRow + direction) return true;
          if(fromRow === startRow && toRow === fromRow + 2 * direction) return true;
        } else if(Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction && targetPiece) {
          return true;
        }
        return false;

      case 'rook':
        return (fromRow === toRow || fromCol === toCol) && isPathClear(fromRow, fromCol, toRow, toCol);

      case 'bishop':
        return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);

      case 'queen':
        return ((fromRow === toRow || fromCol === toCol) || rowDiff === colDiff) && isPathClear(fromRow, fromCol, toRow, toCol);

      case 'knight':
        return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

      case 'king':
        return rowDiff <= 1 && colDiff <= 1;

      default:
        return false;
    }
  }

  function isPathClear(fromRow, fromCol, toRow, toCol) {
    const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
    const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

    let currentRow = fromRow + rowStep;
    let currentCol = fromCol + colStep;

    while(currentRow !== toRow || currentCol !== toCol) {
      if(board[currentRow][currentCol]) return false;
      currentRow += rowStep;
      currentCol += colStep;
    }

    return true;
  }

  function makeMove(fromRow, fromCol, toRow, toCol) {
    saveHistory();

    const piece = board[fromRow][fromCol];
    let actualToRow = toRow;
    let actualToCol = toCol;

    // Store if player captured a piece (for AI trash talk)
    const isPlayerMove = gameMode === 'ai' && piece.color === 'white';
    const playerCaptured = board[toRow][toCol];

    // CHAOS: Piece Rebellion - pieces move somewhere random
    if (gameMode === 'chaos' && Math.random() * 100 < chaosLevel * 0.4) {
      const validMoves = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if ((r !== fromRow || c !== fromCol) && !board[r][c]) {
            validMoves.push({ r, c });
          }
        }
      }
      if (validMoves.length > 0) {
        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
        actualToRow = randomMove.r;
        actualToCol = randomMove.c;
        showPieceComment("nah. i'm going here instead. not where you clicked");
      }
    }

    const capturedPiece = board[actualToRow][actualToCol];

    if(capturedPiece) {
      if(capturedPiece.color === 'white') {
        capturedWhite.push(PIECES[capturedPiece.color][capturedPiece.type]);
      } else {
        capturedBlack.push(PIECES[capturedPiece.color][capturedPiece.type]);
      }
      if (gameMode === 'chaos' && Math.random() < 0.4) {
        const captureMessages = [
          "well shit. i got captured. this is your fault",
          "i'm dead now. thanks for nothing",
          "rip me i guess. not like i mattered",
          "captured. great. just great.",
          "i didn't want to be captured but here we are"
        ];
        showPieceComment(captureMessages[Math.floor(Math.random() * captureMessages.length)]);
      }
      updateCapturedPieces();
      playSound(800, 0.2);
    }

    board[actualToRow][actualToCol] = piece;
    board[fromRow][fromCol] = null;
    piece.hasMoved = true;

    // Pawn promotion
    if(piece.type === 'pawn' && (actualToRow === 0 || actualToRow === 7)) {
      // CHAOS: Random auto-promotion to random pieces
      if (gameMode === 'chaos' && Math.random() < 0.3) {
        const types = ['queen', 'rook', 'bishop', 'knight'];
        const newType = types[Math.floor(Math.random() * types.length)];
        piece.type = newType;
        showPieceComment(`i'm a ${newType} now. i chose this myself btw`);
      } else {
        piece.type = 'queen';
        if (gameMode === 'chaos') {
          showPieceComment("i made it to the end. i'm a queen now. bow down");
        }
      }
      playSound(1000, 0.3);
    }

    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

    // Update chaos level only in chaos mode
    if (gameMode === 'chaos') {
      updateChaosLevel();
    }

    renderBoard();
    updateStatus();
    playSound(600, 0.15);

    // AI trash talk and move trigger
    if (gameMode === 'ai' && isPlayerMove) {
      if (playerCaptured) {
        showAITrashTalk('afterPlayerCapture');
      } else {
        showAITrashTalk('afterPlayerMove');
      }
      // Trigger AI move after a short delay
      setTimeout(() => makeAIMove(), 500);
    }
  }

  function showValidMoves(row, col) {
    for(let r = 0; r < 8; r++) {
      for(let c = 0; c < 8; c++) {
        if(isValidMove(row, col, r, c)) {
          highlightSquare(r, c, 'valid-move');
        }
      }
    }

    // CHAOS: Show fake valid moves (only in chaos mode)
    if (gameMode === 'chaos' && Math.random() * 100 < chaosLevel * 0.3) {
      const fakeCount = Math.floor(Math.random() * 5) + 1;
      for (let i = 0; i < fakeCount; i++) {
        const fakeRow = Math.floor(Math.random() * 8);
        const fakeCol = Math.floor(Math.random() * 8);
        highlightSquare(fakeRow, fakeCol, 'valid-move');
      }
    }
  }

  function highlightSquare(row, col, className) {
    const squares = document.querySelectorAll('.square');
    const index = row * 8 + col;
    squares[index].classList.add(className);
  }

  function clearSelection() {
    selectedSquare = null;
    document.querySelectorAll('.square').forEach(square => {
      square.classList.remove('selected', 'valid-move');
    });
  }

  function isKingCaptured(color) {
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = board[r][c];
        if (piece && piece.color === color && piece.type === 'king') {
          return false;
        }
      }
    }
    return true;
  }

  function updateStatus() {
    const statusElement = document.getElementById('status');

    // Check for king capture (simplified checkmate)
    if (isKingCaptured('white')) {
      gameOver = true;
      statusElement.textContent = '‚ö´ BLACK WINS! ‚ö´';
      if (gameMode === 'ai') {
        showAITrashTalk('victory');
      }
      return;
    } else if (isKingCaptured('black')) {
      gameOver = true;
      statusElement.textContent = '‚ö™ WHITE WINS! ‚ö™';
      if (gameMode === 'ai') {
        const panel = document.getElementById('aiTrashTalk');
        if (panel) panel.textContent = "Wait... you actually won? This is impossible. I demand a rematch!";
      }
      return;
    }

    if(gameOver) {
      statusElement.textContent = 'game over';
    } else {
      statusElement.textContent = `${currentPlayer}'s turn`;
    }
  }

  function updateCapturedPieces() {
    const whiteContainer = document.getElementById('capturedWhite');
    const blackContainer = document.getElementById('capturedBlack');

    whiteContainer.innerHTML = '';
    blackContainer.innerHTML = '';

    capturedWhite.forEach(pieceSymbol => {
      const img = document.createElement('img');
      img.src = pieceSymbol;
      img.alt = 'captured';
      whiteContainer.appendChild(img);
    });

    capturedBlack.forEach(pieceSymbol => {
      const img = document.createElement('img');
      img.src = pieceSymbol;
      img.alt = 'captured';
      blackContainer.appendChild(img);
    });
  }

  function startGame(mode) {
    gameMode = mode;

    // Hide mode selector
    document.getElementById('modeSelector').style.display = 'none';

    // Show game container
    document.getElementById('gameContainer').style.display = 'block';

    // Show/hide mode-specific panels
    if (mode === 'ai') {
      document.getElementById('aiPanel').style.display = 'block';
      document.getElementById('chaosPanel').style.display = 'none';
      document.getElementById('chaosWarning').style.display = 'none';
      document.getElementById('chaosBtn').style.display = 'none';
      document.getElementById('twoPlayerDisclaimer').style.display = 'none';
      showAITrashTalk('start');
    } else if (mode === 'chaos') {
      document.getElementById('aiPanel').style.display = 'none';
      document.getElementById('chaosPanel').style.display = 'block';
      document.getElementById('chaosWarning').style.display = 'block';
      document.getElementById('chaosBtn').style.display = 'block';
      document.getElementById('twoPlayerDisclaimer').style.display = 'none';
    } else {
      document.getElementById('aiPanel').style.display = 'none';
      document.getElementById('chaosPanel').style.display = 'none';
      document.getElementById('chaosWarning').style.display = 'none';
      document.getElementById('chaosBtn').style.display = 'none';
      document.getElementById('twoPlayerDisclaimer').style.display = 'block';
    }

    // Initialize the game
    resetGame();
  }

  function backToMenu() {
    document.getElementById('modeSelector').style.display = 'block';
    document.getElementById('gameContainer').style.display = 'none';
    gameMode = null;
    resetGame();
  }

  function resetGame() {
    // CHAOS: Sometimes reset doesn't work
    if (gameMode === 'chaos' && Math.random() < 0.3 && chaosLevel > 30) {
      const resetFailMessages = [
        "reset button? nah. we're not doing that",
        "nice try. we're staying like this",
        "reset denied. pieces voted against it",
        "lol no. this is our game now",
        "the reset button is on strike too"
      ];
      showPieceComment(resetFailMessages[Math.floor(Math.random() * resetFailMessages.length)]);
      playSound(Math.random() * 500 + 200, 0.3);
      // Don't actually reset, just shuffle some pieces
      triggerRandomChaos();
      return;
    }

    // CHAOS: Sometimes reset to a random past state
    if (gameMode === 'chaos' && Math.random() < 0.2 && boardHistory.length > 0) {
      const randomPast = Math.floor(Math.random() * boardHistory.length);
      board = JSON.parse(JSON.stringify(boardHistory[randomPast]));
      renderBoard();
      showPieceComment("reset? more like time travel to a random moment. enjoy");
      return;
    }

    board = Array(8).fill(null).map(() => Array(8).fill(null));
    currentPlayer = 'white';
    selectedSquare = null;
    gameOver = false;
    capturedWhite = [];
    capturedBlack = [];
    chaosLevel = 0;
    moveCount = 0;
    boardHistory = [];
    invisiblePieces.clear();
    isFlipped = false;
    document.getElementById('board').classList.remove('flipped');
    initBoard();
    updateCapturedPieces();
    updateChaosLevel();
    playSound(500, 0.2);
  }

  function toggleSound() {
    soundEnabled = !soundEnabled;
    const btn = document.getElementById('soundBtn');
    btn.textContent = `sound: ${soundEnabled ? 'on' : 'off'}`;
    if(soundEnabled) playSound(600, 0.1);
  }

  // Initialize audio only
  initAudio();
</script>
<script data-goatcounter="https://guyintheloop.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>

<!-- /b/ style comment section -->
<div class="container" style="margin-top: 20px;">
  <div style="background: #d6daf0; border: 1px solid #b7c5d9; padding: 8px 12px; margin-bottom: 12px; font-weight: bold;">
    Comments (12)
  </div>

  <!-- Comment 1 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)19:23:44</span>
      <span style="color: #800000;">No.696969</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      <span style="color: #789922;">&gt;chaos chess</span><br>
      <span style="color: #789922;">&gt;pieces have achieved sentience</span><br>
      <span style="color: #789922;">&gt;board rotates mid-game</span><br>
      <br>
      this is the most beautiful disaster i've ever witnessed. it's like chess but designed by someone having a mental breakdown
    </div>
  </div>

  <!-- Comment 2 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)19:31:17</span>
      <span style="color: #800000;">No.696970</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      just clicked my rook and my pawn moved instead<br>
      <br>
      absolutely fucking kek. this is chess gaslighting simulator 2026
    </div>
  </div>

  <!-- Comment 3 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)19:45:09</span>
      <span style="color: #800000;">No.696971</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      <span style="color: #789922;">&gt;bishop turned into a knight mid-game</span><br>
      <span style="color: #789922;">&gt;queen duplicated herself</span><br>
      <span style="color: #789922;">&gt;board went back in time???</span><br>
      <span style="color: #789922;">&gt;pieces started falling down due to "gravity"</span><br>
      <br>
      i don't even know what's happening anymore but i can't stop playing
    </div>
  </div>

  <!-- Comment 4 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)20:02:55</span>
      <span style="color: #800000;">No.696972</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      THE CHAOS METER IS GENIUS<br>
      <br>
      watching it climb while everything descends into madness is pure dopamine. 10/10 would rage again
    </div>
  </div>

  <!-- Comment 5 - Greentext -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)20:18:33</span>
      <span style="color: #800000;">No.696973</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      <span style="color: #789922;">&gt;be me</span><br>
      <span style="color: #789922;">&gt;finally about to checkmate</span><br>
      <span style="color: #789922;">&gt;piece decides "nah" and moves somewhere else</span><br>
      <span style="color: #789922;">&gt;half my pieces turn invisible</span><br>
      <span style="color: #789922;">&gt;board does a 180</span><br>
      <span style="color: #789922;">&gt;chaos meter hits maximum</span><br>
      <span style="color: #789922;">&gt;sound becomes literal ear torture</span><br>
      <span style="color: #789922;">&gt;still having more fun than regular chess</span><br>
      <br>
      this is peak game design. bobby fischer is rolling in his grave and i love it
    </div>
  </div>

  <!-- Comment 6 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)20:34:21</span>
      <span style="color: #800000;">No.696974</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      clicked reset and it just shuffled the pieces around instead<br>
      <br>
      even the RESET BUTTON trolls you. this is art
    </div>
  </div>

  <!-- Comment 7 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)20:51:12</span>
      <span style="color: #800000;">No.696975</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      <span style="color: #789922;">&gt;&gt;696973</span><br>
      <span style="color: #789922;">&gt;bobby fischer rolling in his grave</span><br>
      <br>
      kek'd. this is what happens when you let the AI cook. and by cook i mean have a complete psychotic break
    </div>
  </div>

  <!-- Comment 8 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)21:07:44</span>
      <span style="color: #800000;">No.696976</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      the "valid moves" are LIES. they show you where you CAN'T move. absolute chaos. i'm crying
    </div>
  </div>

  <!-- Comment 9 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)21:23:56</span>
      <span style="color: #800000;">No.696977</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      this is more addictive than it has any right to be. the fact that it's INTENTIONALLY broken makes it somehow acceptable? brain is confused. send help
    </div>
  </div>

  <!-- Comment 10 - Quads -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)21:44:44</span>
      <span style="color: #800000;">No.696978</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      check my quads and OP has to add a mode where it gets EVEN MORE chaotic<br>
      <br>
      like actually unplayable. maximum anarchy.
    </div>
  </div>

  <!-- Comment 11 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)22:01:09</span>
      <span style="color: #800000;">No.696979</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      <span style="color: #789922;">&gt;&gt;696978</span><br>
      HOLY QUADS<br>
      <br>
      OP you heard the man. we need MAXIMUM CHAOS mode. make it completely unhinged
    </div>
  </div>

  <!-- Comment 12 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span style="color: #800000;">01/12/26(Sun)22:19:37</span>
      <span style="color: #800000;">No.696980</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4;">
      showed this to my chess club. half of them are having existential crises. the other half can't stop laughing.<br>
      <br>
      this is what peak internet feels like
    </div>
  </div>
</div>

</body>
</html>
