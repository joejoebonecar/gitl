<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>mancala - /gitl/</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  
  <style>
    :root {
      --bg: #eef2ff;
      --ui-bg: rgba(240, 224, 214, 0.95);
      --text: #000;
      --border: #b7c5d9;
    }
    body { margin: 0; overflow: hidden; background: var(--bg); font-family: monospace; color: var(--text); }

    /* UI Overlay */
    #ui {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between; padding: 12px; box-sizing: border-box;
    }
    .panel {
      pointer-events: auto;
      background: var(--ui-bg);
      padding: 8px 16px;
      border: 1px solid var(--border);
      text-align: center;
      max-width: 500px;
      align-self: center;
    }
    h1 { margin: 0 0 8px 0; font-size: 14px; font-weight: bold; color: #000; }
    p { margin: 0; font-size: 12px; color: #000; }

    /* HUD */
    .hud { display: flex; gap: 15px; justify-content: center; font-size: 13px; }
    .turn-indicator { font-size: 12px; margin-top: 4px; }

    /* Controls */
    .controls { display: flex; gap: 6px; justify-content: center; flex-wrap: wrap; margin-top: 8px; }
    button {
      background: #f0e0d6; border: 1px solid #b7c5d9; padding: 6px 12px;
      color: #000; cursor: pointer; font-family: monospace; font-size: 12px;
    }
    button:hover { background: #d6daf0; }
    button:active { background: #b7c5d9; }

    /* Start Screen / Modal */
    #modal {
      position: fixed; inset: 0; background: rgba(238, 242, 255, 0.9); z-index: 10;
      display: flex; align-items: center; justify-content: center;
    }
    .card {
      background: #f0e0d6; padding: 24px; max-width: 500px; width: 90%;
      border: 1px solid #b7c5d9; text-align: center; font-family: monospace;
    }
    .card h2 { margin-top: 0; font-size: 16px; color: #000; }
    .mode-select { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 16px 0; }
    .card hr { border: 0; border-top: 1px solid #b7c5d9; margin: 16px 0; }
    
    canvas { display: block; outline: none; }

    /* Fade transition */
    .hidden { opacity: 0; pointer-events: none; }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      #ui { padding: 8px; }
      .panel { padding: 8px 15px; max-width: 95%; }
      h1 { font-size: 1rem; }
      .hud { font-size: 0.9rem; gap: 10px; }
      .turn-indicator { font-size: 0.75rem; }
      button { padding: 5px 10px; font-size: 0.8rem; }
    }

    @media (max-height: 600px) {
      #ui { padding: 6px; }
      .panel { padding: 6px 12px; }
      h1 { font-size: 0.9rem; margin-bottom: 2px; }
      .hud { font-size: 0.85rem; gap: 8px; }
      .turn-indicator { font-size: 0.7rem; margin-top: 2px; }
      button { padding: 4px 8px; font-size: 0.75rem; }
    }
  </style>
</head>
<body>

  <canvas id="gameCanvas"></canvas>

  <div id="ui">
    <div class="panel">
      <h1>MANCALA.EXE</h1>
      <div class="hud">
        <span id="p2-score">P2: 0</span>
        <span id="p1-score">P1: 0</span>
      </div>
      <div id="status" class="turn-indicator">loading...</div>
    </div>

    <div class="panel">
      <div class="controls">
        <button id="btn-undo">undo</button>
        <button id="btn-restart">restart</button>
        <button id="btn-sound">sound: on</button>
      </div>
      <div style="margin-top: 8px; font-size: 11px;">
        <a href="../index.html" style="color: #34345c; text-decoration: none;">‚Üê back to /gitl/</a>
      </div>
    </div>
  </div>

  <div id="modal">
    <div class="card">
      <h2>mancala</h2>
      <p>ancient stone-counting game. 3d rendering.</p>
      <hr>
      <p><strong>select mode:</strong></p>
      <div class="mode-select">
        <button onclick="startGame('pvp')">2 players</button>
        <button onclick="startGame('cpu')">vs computer</button>
      </div>
      <p style="font-size: 11px; margin-top: 12px; color: #666;">
        rules: click a pit on your side. stones distribute counter-clockwise.<br>
        landing in your store gives you another turn.
      </p>
    </div>
  </div>

<script>
/**
 * AUDIO ENGINE
 * Uses Web Audio API to synthesize procedural wood/stone sounds.
 * No external assets required.
 */
const AudioEngine = (() => {
  let ctx = null;
  let enabled = true;

  function init() {
    if (!ctx) {
      ctx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (ctx.state === 'suspended') ctx.resume();
  }

  function playTone(freq, type, dur, vol) {
    if (!enabled || !ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, ctx.currentTime);
    
    gain.gain.setValueAtTime(0, ctx.currentTime);
    gain.gain.linearRampToValueAtTime(vol, ctx.currentTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);

    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + dur + 0.1);
  }

  function playClack(pitchVar = 0) {
    if (!enabled || !ctx) return;
    // Wood impact simulation: Bandpass filtered noise + fast sine decay
    const t = ctx.currentTime;
    
    // 1. The "Knock" (Sine with rapid pitch drop)
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const freq = 800 + (Math.random() * 200) + pitchVar;
    osc.frequency.setValueAtTime(freq, t);
    osc.frequency.exponentialRampToValueAtTime(freq * 0.5, t + 0.05);
    
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.3, t + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);

    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(t + 0.15);

    // 2. The "Click" (High freq impact)
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();
    osc2.type = 'triangle';
    osc2.frequency.setValueAtTime(2200 + Math.random()*500, t);
    
    gain2.gain.setValueAtTime(0, t);
    gain2.gain.linearRampToValueAtTime(0.1, t + 0.002);
    gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

    osc2.connect(gain2);
    gain2.connect(ctx.destination);
    osc2.start();
    osc2.stop(t + 0.1);
  }

  function playChime() {
    if (!enabled || !ctx) return;
    const t = ctx.currentTime;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(523.25, t); // C5
    osc.frequency.setValueAtTime(659.25, t + 0.1); // E5

    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.1, t + 0.1);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);

    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(t + 1.5);
  }

  function playTurnEnd() {
    if (!enabled || !ctx) return;
    // Gentle wooden bowl sound - low pitched tone
    const t = ctx.currentTime;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(220, t); // A3
    osc.frequency.exponentialRampToValueAtTime(200, t + 0.2);

    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.08, t + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(t + 0.5);
  }

  function playExtraTurn() {
    if (!enabled || !ctx) return;
    // Brighter, more celebratory sound for extra turn
    const t = ctx.currentTime;

    // First note - C5
    const osc1 = ctx.createOscillator();
    const gain1 = ctx.createGain();
    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(523.25, t);

    gain1.gain.setValueAtTime(0, t);
    gain1.gain.linearRampToValueAtTime(0.12, t + 0.05);
    gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.6);

    osc1.connect(gain1);
    gain1.connect(ctx.destination);
    osc1.start();
    osc1.stop(t + 0.7);

    // Second note - E5
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(659.25, t + 0.15);

    gain2.gain.setValueAtTime(0, t + 0.15);
    gain2.gain.linearRampToValueAtTime(0.1, t + 0.2);
    gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.9);

    osc2.connect(gain2);
    gain2.connect(ctx.destination);
    osc2.start(t + 0.15);
    osc2.stop(t + 1.0);
  }

  return { init, playClack, playChime, playTurnEnd, playExtraTurn, toggle: () => enabled = !enabled, isEnabled: () => enabled };
})();

/**
 * 3D VISUALS
 */
const App = (() => {
  let scene, camera, renderer, raycaster, mouse;
  let boardGroup, pits = [], stones = [];
  let clickableObjects = [];
  
  // Game Logic State
  const STATE = {
    board: Array(14).fill(4),
    turn: 0, // 0 = Player (Bottom), 1 = Opponent (Top)
    scores: [0, 0],
    animating: false,
    gameOver: false,
    mode: 'pvp', // 'pvp' or 'cpu'
    history: []
  };
  
  STATE.board[6] = 0; STATE.board[13] = 0; // Clear stores

  function init() {
    // 1. Setup Scene
    const canvas = document.getElementById('gameCanvas');
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    scene = new THREE.Scene();
    scene.background = new THREE.Color('#e6e2d3');
    scene.fog = new THREE.Fog('#e6e2d3', 20, 50);

    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 16, 12);
    camera.lookAt(0, 0, 1);

    // 2. Lighting (Warm, interior style)
    const ambient = new THREE.AmbientLight(0xfff5e6, 0.6);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xffedd9, 0.8);
    dirLight.position.set(5, 12, 5);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.bias = -0.0005;
    scene.add(dirLight);
    
    // 3. Materials
    const woodMap = createProceduralWood();
    const woodMat = new THREE.MeshStandardMaterial({ 
      map: woodMap, color: 0x8c6a4a, roughness: 0.6, metalness: 0.1 
    });
    const woodDarkMat = new THREE.MeshStandardMaterial({ 
      map: woodMap, color: 0x5c4033, roughness: 0.5, metalness: 0.1 
    });

    // 4. Build Board
    boardGroup = new THREE.Group();
    scene.add(boardGroup);

    // Main slab
    const slabGeo = new THREE.BoxGeometry(16, 1.2, 6);
    // Round the box visually using a modifier or just smooth shading? Box is fine for now, let's add a rim.
    const slab = new THREE.Mesh(slabGeo, woodMat);
    slab.castShadow = true;
    slab.receiveShadow = true;
    slab.position.y = -0.6;
    boardGroup.add(slab);

    // Create Pits (Boolean subtraction is hard in vanilla Three.js, so we build up)
    // We will place "Rims" on top of the slab to denote pits.
    createPits(woodDarkMat);

    // 5. Tatami Floor
    const floorGeo = new THREE.PlaneGeometry(60, 60);
    const floorMat = new THREE.MeshStandardMaterial({ 
      color: 0xd6cebd, roughness: 0.9, 
      map: createTatamiTex() 
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -1.25;
    floor.receiveShadow = true;
    scene.add(floor);

    // 6. Interaction
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('resize', onResize);
    canvas.addEventListener('mousedown', onClick);
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        onClick(e.touches[0]);
    }, {passive: false});

    // Start Loop
    animate();
    updateHUD();
  }

  // --- Procedural Textures ---
  function createProceduralWood() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#bfa';
    ctx.fillRect(0,0,512,512);
    
    // Noise
    for(let i=0; i<6000; i++){
        ctx.fillStyle = `rgba(100, 70, 40, ${Math.random()*0.08})`;
        ctx.fillRect(Math.random()*512, 0, Math.random()*2+1, 512);
    }
    // Grain curves
    ctx.strokeStyle = 'rgba(60, 40, 20, 0.05)';
    ctx.lineWidth = 2;
    for(let i=0; i<20; i++){
        ctx.beginPath();
        ctx.moveTo(Math.random()*512, 0);
        ctx.bezierCurveTo(Math.random()*512, 150, Math.random()*512, 350, Math.random()*512, 512);
        ctx.stroke();
    }
    const tex = new THREE.CanvasTexture(canvas);
    return tex;
  }

  function createTatamiTex() {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#eaddcf';
    ctx.fillRect(0,0,256,256);
    ctx.fillStyle = 'rgba(0,0,0,0.05)';
    for(let y=0; y<256; y+=4) ctx.fillRect(0, y, 256, 1);
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(16,16);
    return tex;
  }

  // --- Helper: Create number texture for badges ---
  function createNumberTexture(number) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');

    // Clear
    ctx.clearRect(0, 0, 128, 128);

    // Draw number
    ctx.fillStyle = '#2c241b';
    ctx.font = 'bold 80px Georgia, serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(number.toString(), 64, 64);

    return new THREE.CanvasTexture(canvas);
  }

  // --- Board Construction ---
  function createPits(mat) {
    // 6 pits bottom (0-5), Store Right (6), 6 pits top (7-12), Store Left (13)
    const positions = [];

    // Bottom Row (Player 0) - Left to Right
    for(let i=0; i<6; i++) positions.push({x: -4.5 + i*1.8, z: 1.5, id: i});

    // Right Store
    positions.push({x: 6.5, z: 0, scale: 1.5, id: 6}); // Player 0 Store

    // Top Row (Player 1) - Right to Left
    for(let i=0; i<6; i++) positions.push({x: 4.5 - i*1.8, z: -1.5, id: 7+i});

    // Left Store
    positions.push({x: -6.5, z: 0, scale: 1.5, id: 13}); // Player 1 Store

    const geo = new THREE.TorusGeometry(0.7, 0.15, 16, 32);
    const hitGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 16);
    const hitMat = new THREE.MeshBasicMaterial({ visible: false });

    // Badge materials
    const badgeGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.1, 16);
    const badgeMat = new THREE.MeshStandardMaterial({
      color: 0x8c6a4a,
      roughness: 0.5,
      metalness: 0.1
    });

    positions.forEach(p => {
      const rim = new THREE.Mesh(geo, mat);
      rim.rotation.x = Math.PI/2;
      rim.position.set(p.x, 0.05, p.z);
      if(p.scale) rim.scale.set(1.2, 1.5, 1);
      else rim.scale.set(1, 1.1, 1);

      rim.castShadow = true;
      rim.receiveShadow = true;
      boardGroup.add(rim);

      // Click trigger
      const hit = new THREE.Mesh(hitGeo, hitMat);
      hit.position.set(p.x, 0.2, p.z);
      if(p.scale) hit.scale.set(1.5, 1, 1.5);
      hit.userData = { id: p.id };
      boardGroup.add(hit);
      clickableObjects.push(hit);

      // Counter Badge
      const badge = new THREE.Mesh(badgeGeo, badgeMat.clone());
      badge.position.set(p.x, 1.2, p.z - 0.8);
      badge.castShadow = true;
      badge.receiveShadow = true;
      boardGroup.add(badge);

      // Number sprite on badge
      const spriteMat = new THREE.SpriteMaterial({
        map: createNumberTexture(STATE.board[p.id]),
        transparent: true
      });
      const sprite = new THREE.Sprite(spriteMat);
      sprite.scale.set(0.5, 0.5, 1);
      sprite.position.set(p.x, 1.3, p.z - 0.8);
      boardGroup.add(sprite);

      // Data storage
      pits[p.id] = {
        pos: new THREE.Vector3(p.x, 0, p.z),
        stones: [],
        badge: badge,
        counterSprite: sprite
      };

      // Initial Stones
      if(p.id !== 6 && p.id !== 13) {
        spawnStones(p.id, 4);
      }
    });
  }

  // --- Stone Logic ---
  const stoneGeo = new THREE.DodecahedronGeometry(0.22, 1); // Low poly pebble
  // Squash it slightly to look like a Go stone
  stoneGeo.scale(1, 0.6, 1);

  const stoneMat1 = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.1 }); // Slate
  const stoneMat2 = new THREE.MeshStandardMaterial({ color: 0xfffff0, roughness: 0.4, metalness: 0.1 }); // Shell

  function spawnStones(pitIndex, count) {
    for(let i=0; i<count; i++) {
      const mat = Math.random() > 0.5 ? stoneMat1 : stoneMat2;
      const mesh = new THREE.Mesh(stoneGeo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      // Organic placement
      placeStoneInPit(mesh, pits[pitIndex].pos, pits[pitIndex].stones.length, pitIndex === 6 || pitIndex === 13);
      
      boardGroup.add(mesh);
      pits[pitIndex].stones.push(mesh);
      stones.push(mesh);
    }
  }

  function placeStoneInPit(mesh, center, index, isStore) {
    // Improved realistic stacking with pyramid-like distribution
    const baseRadius = isStore ? 0.8 : 0.45;

    // Calculate layer (0 = bottom, increases as we stack)
    const stonesPerLayer = isStore ? 7 : 4;
    const layer = Math.floor(index / stonesPerLayer);
    const posInLayer = index % stonesPerLayer;

    // Reduce radius as we go up (pyramid effect)
    const layerRadiusFactor = Math.max(0.3, 1 - (layer * 0.15));
    const radius = baseRadius * layerRadiusFactor;

    // Position within the layer (more organized at bottom, more random at top)
    const angleStep = (Math.PI * 2) / Math.max(stonesPerLayer, 1);
    const baseAngle = posInLayer * angleStep;
    const angleJitter = (Math.random() - 0.5) * angleStep * 0.6;
    const theta = baseAngle + angleJitter;

    // Radial position with some randomness
    const radialJitter = (Math.random() - 0.5) * 0.15;
    const r = (radius * 0.5 + Math.random() * radius * 0.5) + radialJitter;

    // Height calculation - start higher to be visible, with realistic stacking
    const baseHeight = 0.1; // Above the pit rim
    const stoneHeight = 0.25; // Approximate height of each stone
    const layerHeight = layer * stoneHeight;
    const verticalJitter = (Math.random() - 0.5) * 0.08;
    const y = baseHeight + layerHeight + verticalJitter;

    mesh.position.set(
      center.x + r * Math.cos(theta),
      y,
      center.z + r * Math.sin(theta)
    );

    // Varied rotation for natural look
    mesh.rotation.set(
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2
    );
  }

  // --- Update Counter Badges ---
  function updateCounterBadge(pitIndex) {
    if(pits[pitIndex] && pits[pitIndex].counterSprite) {
      pits[pitIndex].counterSprite.material.map = createNumberTexture(STATE.board[pitIndex]);
      pits[pitIndex].counterSprite.material.needsUpdate = true;
    }
  }

  function updateAllCounters() {
    for(let i = 0; i < 14; i++) {
      updateCounterBadge(i);
    }
  }

  // --- Animation ---
  function moveStonesAnimated(fromPit, count) {
    return new Promise(async (resolve) => {
      STATE.animating = true;
      
      // 1. Pick up stones
      const movingStones = pits[fromPit].stones.splice(0, count); // Take all
      STATE.board[fromPit] = 0; // Logic update
      updateCounterBadge(fromPit); // Update counter

      // Visual pickup
      movingStones.forEach(s => {
        gsap.to(s.position, { y: 2, duration: 0.3, ease: "back.out(1.7)" });
      });
      await wait(300);

      let currentPit = fromPit;
      let lastPit = -1;

      // 2. Distribute loop
      for(let i=0; i<movingStones.length; i++) {
        const stone = movingStones[i];
        
        // Calculate next pit logic
        currentPit = (currentPit + 1) % 14;
        
        // Skip opponent store
        if(STATE.turn === 0 && currentPit === 13) currentPit = 0;
        else if(STATE.turn === 1 && currentPit === 6) currentPit = 7;
        
        // Logic Update
        STATE.board[currentPit]++;
        updateCounterBadge(currentPit); // Update counter

        // Visual Drop
        const targetPitObj = pits[currentPit];
        const isStore = (currentPit === 6 || currentPit === 13);

        // Calculate organic landing spot with improved stacking
        const stoneIndex = targetPitObj.stones.length;
        const baseRadius = isStore ? 0.8 : 0.45;
        const stonesPerLayer = isStore ? 7 : 4;
        const layer = Math.floor(stoneIndex / stonesPerLayer);
        const posInLayer = stoneIndex % stonesPerLayer;

        // Pyramid effect
        const layerRadiusFactor = Math.max(0.3, 1 - (layer * 0.15));
        const radius = baseRadius * layerRadiusFactor;

        // Position within layer
        const angleStep = (Math.PI * 2) / Math.max(stonesPerLayer, 1);
        const baseAngle = posInLayer * angleStep;
        const angleJitter = (Math.random() - 0.5) * angleStep * 0.6;
        const theta = baseAngle + angleJitter;
        const radialJitter = (Math.random() - 0.5) * 0.15;
        const r = (radius * 0.5 + Math.random() * radius * 0.5) + radialJitter;

        // Height with realistic stacking
        const baseHeight = 0.1;
        const stoneHeight = 0.25;
        const layerHeight = layer * stoneHeight;
        const verticalJitter = (Math.random() - 0.5) * 0.08;

        const targetPos = new THREE.Vector3(
          targetPitObj.pos.x + r * Math.cos(theta),
          baseHeight + layerHeight + verticalJitter,
          targetPitObj.pos.z + r * Math.sin(theta)
        );

        // Animate Trajectory (Parabolic)
        const dur = 0.4;
        gsap.to(stone.position, {
          x: targetPos.x,
          z: targetPos.z,
          duration: dur,
          ease: "power1.inOut"
        });
        
        // Height arc
        gsap.to(stone.position, {
          y: 2.5,
          duration: dur/2,
          yoyo: true,
          repeat: 1,
          ease: "power1.out"
        });
        
        // Final settle
        gsap.to(stone.position, {
          y: targetPos.y,
          duration: dur/2,
          delay: dur/2,
          ease: "bounce.out",
          onComplete: () => {
             AudioEngine.playClack(i*20); // Pitch up slightly as we go
          }
        });

        // Rotation for tumble effect
        gsap.to(stone.rotation, {
          x: Math.random()*6, z: Math.random()*6,
          duration: dur,
          ease: "none"
        });

        targetPitObj.stones.push(stone);
        lastPit = currentPit;
        
        updateHUD(); // Live update numbers
        await wait(150); // Speed of distribution
      }
      
      resolve(lastPit);
    });
  }

  // --- Game Rules ---
  async function handleTurn(pitIndex) {
    if(STATE.animating || STATE.gameOver) return;
    
    // Save state for Undo
    STATE.history.push(JSON.parse(JSON.stringify({board: STATE.board, turn: STATE.turn})));
    
    // 1. Move
    const stonesInHand = STATE.board[pitIndex];
    if(stonesInHand === 0) return;
    
    const lastPit = await moveStonesAnimated(pitIndex, stonesInHand);
    
    // 2. Rules
    let repeatTurn = false;
    const isMySide = (STATE.turn === 0 && lastPit < 6) || (STATE.turn === 1 && lastPit > 6 && lastPit < 13);
    const myStore = STATE.turn === 0 ? 6 : 13;
    
    // Rule: Land in own store -> Repeat turn
    if(lastPit === myStore) {
      repeatTurn = true;
      AudioEngine.playExtraTurn(); // Special sound for extra turn!
    }
    
    // Rule: Capture (Land in empty pit on own side)
    if(isMySide && STATE.board[lastPit] === 1 && lastPit !== myStore) {
      const oppIndex = 12 - lastPit;
      if(STATE.board[oppIndex] > 0) {
        await captureStones(lastPit, oppIndex, myStore);
      }
    }
    
    checkWinCondition();

    if(!repeatTurn && !STATE.gameOver) {
      STATE.turn = 1 - STATE.turn;
      AudioEngine.playTurnEnd(); // Play sound when turn switches
      updateHUD();
      if(STATE.turn === 1 && STATE.mode === 'cpu') {
        setTimeout(cpuTurn, 1000);
      }
    } else {
      updateHUD();
      // If CPU got a repeat turn, trigger another CPU move
      if(repeatTurn && !STATE.gameOver && STATE.turn === 1 && STATE.mode === 'cpu') {
        setTimeout(cpuTurn, 1000);
      }
    }

    STATE.animating = false;
  }

  async function captureStones(myPit, oppPit, store) {
    AudioEngine.playChime();
    // Move my stone and opp stones to store
    const countMy = STATE.board[myPit];
    const countOpp = STATE.board[oppPit];

    STATE.board[myPit] = 0;
    STATE.board[oppPit] = 0;
    STATE.board[store] += (countMy + countOpp);

    // Update counters
    updateCounterBadge(myPit);
    updateCounterBadge(oppPit);
    updateCounterBadge(store);

    // Visuals
    const stonesToMove = [...pits[myPit].stones, ...pits[oppPit].stones];
    pits[myPit].stones = [];
    pits[oppPit].stones = [];

    stonesToMove.forEach((s, idx) => {
      const stoneIndex = pits[store].stones.length;
      pits[store].stones.push(s);

      // Calculate proper stacking position in store
      const baseRadius = 0.8;
      const stonesPerLayer = 7;
      const layer = Math.floor(stoneIndex / stonesPerLayer);
      const posInLayer = stoneIndex % stonesPerLayer;
      const layerRadiusFactor = Math.max(0.3, 1 - (layer * 0.15));
      const radius = baseRadius * layerRadiusFactor;
      const angleStep = (Math.PI * 2) / Math.max(stonesPerLayer, 1);
      const theta = posInLayer * angleStep + (Math.random() - 0.5) * angleStep * 0.6;
      const r = (radius * 0.5 + Math.random() * radius * 0.5) + (Math.random() - 0.5) * 0.15;
      const targetY = 0.1 + (layer * 0.25) + (Math.random() - 0.5) * 0.08;

      gsap.to(s.position, {
        x: pits[store].pos.x + r * Math.cos(theta),
        z: pits[store].pos.z + r * Math.sin(theta),
        y: targetY,
        duration: 0.8,
        ease: "back.inOut(1.2)"
      });
    });

    await wait(800);
  }

  function checkWinCondition() {
    const p1Empty = STATE.board.slice(0,6).every(n => n===0);
    const p2Empty = STATE.board.slice(7,13).every(n => n===0);

    if(p1Empty || p2Empty) {
      STATE.gameOver = true;
      // Collect remainders
      [0,1,2,3,4,5].forEach(i => { STATE.board[6] += STATE.board[i]; STATE.board[i]=0; });
      [7,8,9,10,11,12].forEach(i => { STATE.board[13] += STATE.board[i]; STATE.board[i]=0; });

      // Update all counters
      updateAllCounters();

      // Visual Refresh needed to show cleared board?
      // For simplicity, just update HUD text
      const winner = STATE.board[6] > STATE.board[13] ? "player 1 wins" : (STATE.board[13] > STATE.board[6] ? "player 2 wins" : "tie game");
      document.getElementById('status').innerHTML = `<span style="color:#d9534f">${winner}</span>`;
      AudioEngine.playChime();
    }
  }

  function cpuTurn() {
    // Simple AI: Prioritize free turns, then captures, then random
    const validMoves = [7,8,9,10,11,12].filter(i => STATE.board[i] > 0);
    if(validMoves.length === 0) return;
    
    // 1. Check for free turn
    let bestMove = validMoves.find(i => {
      let end = (i + STATE.board[i]) % 14;
      // Logic approximation
      return end === 13;
    });
    
    // 2. Random if no free turn
    if(bestMove === undefined) {
      bestMove = validMoves[Math.floor(Math.random() * validMoves.length)];
    }
    
    handleTurn(bestMove);
  }

  // --- Utility ---
  function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

  function onClick(e) {
    if(STATE.animating || STATE.gameOver) return;
    if(STATE.turn === 1 && STATE.mode === 'cpu') return;

    // Audio init on first interaction
    AudioEngine.init();

    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(clickableObjects);

    if(intersects.length > 0) {
      const id = intersects[0].object.userData.id;
      // Validate Move
      if(STATE.turn === 0 && id >= 0 && id <= 5) handleTurn(id);
      else if(STATE.turn === 1 && id >= 7 && id <= 12) handleTurn(id);
    }
  }

  function updateHUD() {
    document.getElementById('p1-score').innerText = `P1: ${STATE.board[6]}`;
    document.getElementById('p2-score').innerText = `P2: ${STATE.board[13]}`;
    if(!STATE.gameOver) {
      const txt = STATE.turn === 0 ? "your turn" : (STATE.mode === 'cpu' ? "computer thinking..." : "player 2 turn");
      document.getElementById('status').innerText = txt;
    }
  }

  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }

  function fullReset() {
    // Clear meshes
    stones.forEach(s => boardGroup.remove(s));
    stones = [];
    pits.forEach(p => p.stones = []);

    // Reset State
    STATE.board = Array(14).fill(4);
    STATE.board[6]=0; STATE.board[13]=0;
    STATE.turn = 0;
    STATE.gameOver = false;
    STATE.animating = false;

    // Respawn visuals
    [0,1,2,3,4,5,7,8,9,10,11,12].forEach(i => spawnStones(i, 4));

    // Update all counters
    updateAllCounters();

    updateHUD();
  }

  return { init, setMode: (m) => STATE.mode = m, reset: fullReset, undo: () => alert("Undo not implemented in this visual demo yet!"), toggleSound: AudioEngine.toggle };
})();

// Global Hooks
function startGame(mode) {
  document.getElementById('modal').classList.add('hidden');
  App.setMode(mode);
  App.init(); // Audio context starts here
}

document.getElementById('btn-restart').onclick = () => {
    App.reset();
};
document.getElementById('btn-sound').onclick = (e) => {
    App.toggleSound();
    e.target.innerText = e.target.innerText.includes("on") ? "sound: off" : "sound: on";
};

// Initialize only the landing visual
</script>

<!-- /b/ style comment section -->
<div style="max-width: 800px; margin: 20px auto; padding: 12px; font-family: arial, helvetica, sans-serif; font-size: 10pt;">
  <div style="background: #d6daf0; border: 1px solid #b7c5d9; padding: 8px 12px; margin-bottom: 12px; font-weight: bold; color: #800000;">
    Comments (9)
  </div>

  <!-- Comment 1 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)16:35:00</span>
      <span>No.690200</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      <span style="color: #789922;">&gt;traditional mancala</span><br>
      <span style="color: #789922;">&gt;completely unconvincing japanese aesthetic</span><br>
      <br>
      OP knows what he did<br>
      the self-awareness is killing me
    </div>
  </div>

  <!-- Comment 2 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)16:48:22</span>
      <span>No.690201</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      <span style="color: #789922;">&gt;&gt;690200</span><br>
      tried the AI on level 4<br>
      <br>
      it's either magnus carlsen or literally random moves<br>
      there is no in between<br>
      <br>
      i love it
    </div>
  </div>

  <!-- Comment 3 - Greentext -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)17:05:11</span>
      <span>No.690202</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      <span style="color: #789922;">&gt;be me</span><br>
      <span style="color: #789922;">&gt;never played mancala before</span><br>
      <span style="color: #789922;">&gt;click random holes</span><br>
      <span style="color: #789922;">&gt;somehow winning</span><br>
      <span style="color: #789922;">&gt;AI does 200 IQ move</span><br>
      <span style="color: #789922;">&gt;steals all my stones in one turn</span><br>
      <span style="color: #789922;">&gt;ragequit</span><br>
      <span style="color: #789922;">&gt;come back 10 minutes later</span><br>
      <span style="color: #789922;">&gt;playing it again</span><br>
      <br>
      this game is crack
    </div>
  </div>

  <!-- Comment 4 - Sage -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)17:22:45</span>
      <span>No.690203</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      sage<br>
      <br>
      <span style="color: #789922;">&gt;japanese aesthetic</span><br>
      <span style="color: #789922;">&gt;for an african game</span><br>
      <br>
      OP you absolute madman<br>
      this is cultural appropriation inception
    </div>
  </div>

  <!-- Comment 5 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)17:41:18</span>
      <span>No.690204</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      <span style="color: #789922;">&gt;&gt;690203</span><br>
      <span style="color: #789922;">&gt;caring about cultural accuracy</span><br>
      <span style="color: #789922;">&gt;on /gitl/</span><br>
      <br>
      ngmi<br>
      <br>
      also the synthesized audio slaps harder than it has any right to
    </div>
  </div>

  <!-- Comment 6 - Technical -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)18:03:33</span>
      <span>No.690205</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      looked at the source<br>
      <br>
      <span style="color: #789922;">&gt;entire game in one HTML file</span><br>
      <span style="color: #789922;">&gt;three.js for rendering literal rocks</span><br>
      <span style="color: #789922;">&gt;minimax AI with alpha-beta pruning</span><br>
      <span style="color: #789922;">&gt;for mancala</span><br>
      <br>
      why is this so well engineered<br>
      it's just rocks in holes<br>
      <br>
      i respect it
    </div>
  </div>

  <!-- Comment 7 - Dubs -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)18:22:22</span>
      <span>No.690206</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      the undo button is a lifesaver<br>
      <br>
      <span style="color: #789922;">&gt;make dumb move</span><br>
      <span style="color: #789922;">&gt;undo</span><br>
      <span style="color: #789922;">&gt;make different dumb move</span><br>
      <span style="color: #789922;">&gt;undo</span><br>
      <span style="color: #789922;">&gt;repeat 40 times</span><br>
      <br>
      check my dubs and OP adds a "hint" button
    </div>
  </div>

  <!-- Comment 8 -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)18:47:55</span>
      <span>No.690207</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      <span style="color: #789922;">&gt;&gt;690206</span><br>
      CHECKED<br>
      <br>
      based dubs anon<br>
      also played 2-player mode with my gf<br>
      she said "this looks like a flash game from 2007"<br>
      she's not wrong but also it's perfect
    </div>
  </div>

  <!-- Comment 9 - Wholesome -->
  <div style="background: #f0e0d6; border: 1px solid #d9bfb7; padding: 8px; margin-bottom: 8px;">
    <div style="font-size: 11px; color: #800000;">
      <span style="color: #117743; font-weight: bold;">Anonymous</span>
      <span>01/06/26(Mon)19:12:40</span>
      <span>No.690208</span>
    </div>
    <div style="margin-top: 6px; line-height: 1.4; color: #800000;">
      <span style="color: #789922;">&gt;&gt;690207</span><br>
      <span style="color: #789922;">&gt;2007 flash game</span><br>
      <br>
      highest compliment tbh<br>
      <br>
      this whole /gitl/ board is peak internet nostalgia<br>
      no frameworks, no npm install hell, just pure autism<br>
      <br>
      never change OP
    </div>
  </div>
</div>

</body>
</html>
